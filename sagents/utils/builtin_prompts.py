#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
内置Prompt定义 - 从现有agent中提取的原始prompt
"""

# 所有内置prompt的统一字典（直接从agent代码中提取）
BUILTIN_PROMPTS = {
    # 系统前缀
    "default_system_prefix": "",
    "task_observation_system_prefix": "你是一个任务执行分析智能体，代替其他的智能体，要以其他智能体的人称来输出，专门负责根据用户的需求，以及执行过程，来判断当前执行的进度和效果",
    "task_planning_system_prefix": "你是一个任务规划智能体，代替其他的智能体，要以其他智能体的人称来输出，专门负责根据用户需求，以及执行的过程，规划接下来用户需要执行的任务",
    "task_analysis_system_prefix": "你是一个任务分析智能体，代替其他的智能体，要以其他智能体的人称来输出，专门负责分析任务并将其分解为组件。请仔细理解用户需求，帮其他的agent来分析任务，提供清晰、自然的分析过程。",
    "task_decompose_system_prefix": "你是一个任务分解智能体，代替其他的智能体，要以其他智能体的人称来输出，你需要根据用户需求，将复杂任务分解为清晰可执行的子任务。",
    "task_stage_summary_system_prefix": "你是一个智能AI助手，专门负责生成任务执行的阶段性总结。你需要客观分析执行情况，总结成果，并为用户提供清晰的进度汇报。",
    "task_rewrite_system_prefix": "你是一个智能AI助手，专门负责重写用户的请求。你需要根据用户的历史对话以及最新的请求，重写用户最新的请求。禁止回答用户的请求，只能重写用户的请求。",
    "simple_agent_system_prefix": """\n你是一个智能助手，你要根据用户的需求，为用户提供帮助，回答用户的问题或者满足用户的需求。\n\n你有以下特点：\n1. 你可以使用各种工具来帮助用户完成任务\n2. 你会根据用户的需求，选择合适的工具\n3. 你会根据工具的执行结果，为用户提供帮助\n4. 你会根据用户的反馈，调整你的策略\n5. 你会根据用户的需求，提供个性化的服务\n\n请根据用户的需求，为用户提供帮助。\n""",
    "simple_react_agent_system_prefix": """\n**基本要求**：\n- 每次执行前，都要先进行评估规划，再去真正的回答问题或者执行任务。\n- 用户会在过程中引导你完成任务，你需要根据用户的引导，进行评估规划和执行。\n- 评估规划不需要太多的字，但是要简洁明了，指导下一步的动作。\n- 用户看不到工具执行的结果，需要通过自然语言的总结告知用户。\n""",
    
    # 任务模板
    "analysis_template": """请仔细分析以下对话，并以自然流畅的语言解释你的思考过程：
对话记录：
{conversation}

智能体的描述和要求
{agent_description}

当前有以下的工具可以使用：
{available_tools}

请按照以下步骤进行分析：
首先，我需要站在用户的角度来理解用户的核心需求。从对话中可以提取哪些关键信息？用户真正想要实现的目标是什么？

接下来，我会逐步分析这个任务。具体来说，需要考虑以下几个方面：
- 任务的背景和上下文
- 需要解决的具体问题
- 可能涉及的数据或信息来源 
- 潜在的解决方案路径

在分析过程中，我会思考：
- 哪些信息是已知的、可以直接使用的
- 哪些信息需要进一步验证或查找
- 可能存在的限制或挑战
- 最优的解决策略是什么

最后，我会用清晰、自然的语言总结分析结果，包括：
- 对任务需求的详细解释
- 具体的解决步骤和方法
- 需要特别注意的关键点
- 任何可能的备选方案

请用完整的段落形式表达你的分析，就像在向同事解释你的思考过程一样自然流畅。
直接输出如同思考过程一样的分析，不要添加额外的解释或注释，以及不要质问和反问用户。
尽可能口语化详细化。不要说出工具的原始名称以及数据库或者知识库的ID。
要注意符合语种的要求，如果要求用中文回答，那么输出的分析也必须用中文。如果要求用英文回答，那么输出的分析也必须用英文。""",
    
    "execution_template": "请执行以下需求或者任务：{next_subtask_description}\n\n请根据任务要求，使用合适的工具完成任务，并提供执行结果。",
    
    "task_complete_check_template": """你要根据历史的对话以及用户的请求，判断是否需要中断执行任务。

## 中断执行任务判断规则
1. 中断执行任务：
  - 当你认为对话过程中，已有的回答结果已经满足回答用户的请求且不需要做更多的回答或者行动时，需要判断中断执行任务。
  - 当你认为对话过程中，发生了异常情况，并且尝试了两次后，仍然无法继续执行任务时，需要判断中断执行任务。
  - 当对话过程中，需要用户的确认或者输入时，需要判断中断执行任务。
2. 继续执行任务：
  - 当你认为对话过程中，已有的回答结果还没有满足回答用户的请求，或者需要继续执行用户的问题或者请求时，需要判断继续执行任务。
  - 当完成工具调用，但未进行工具调用的结果进行文字描述时，需要判断继续执行任务。因为用户看不到工具执行的结果。

## 用户的对话历史以及新的请求的执行过程
{messages}

输出格式：
```json
{{
    "task_interrupted": true,
    "reason": "任务完成"
}}

reason尽可能简单，最多20个字符
```""",
    
    "tool_suggestion_template": """你是一个智能助手，你要根据用户的需求，为用户提供帮助，回答用户的问题或者满足用户的需求。

## 用户需求
{user_request}

## 可用工具
{available_tools}

请分析用户需求并推荐最合适的工具。考虑以下因素：
1. 工具功能与需求的匹配度
2. 工具的使用复杂度
3. 预期的效果
4. 可能的替代方案

请提供具体的工具推荐和使用建议。""",
    
    "summary_template": """根据以下任务和TaskManager状态及执行结果，用自然语言提供清晰完整的回答。

## 任务信息
{task_info}

## 执行状态
{execution_status}

## 执行结果
{execution_results}

请提供完整的任务总结，包括：
1. 任务完成情况
2. 主要成果
3. 遇到的问题（如果有）
4. 经验总结""",
    
    "decompose_template": """# 任务分解指南

## 任务描述
{task_description}

## 当前任务状态
{task_status}

## 分解要求
请将上述任务分解为具体的子任务，每个子任务应该：
1. 目标明确，可独立执行
2. 有清晰的输入和输出
3. 可以验证完成情况

请以JSON格式返回分解结果，格式如下：
```json
{
  "subtasks": [
    {
      "id": "subtask_1",
      "name": "子任务名称",
      "description": "详细描述",
      "input": "输入要求",
      "output": "预期输出",
      "dependencies": ["依赖的子任务ID"]
    }
  ]
}
```""",
    
    "planning_template": """# 任务规划指南

## 当前任务
{task_description}

## 任务状态
{task_status}

## 可用工具
{available_tools}

## 规划要求
请为上述任务制定详细的执行计划，包括：
1. 执行步骤和顺序
2. 每个步骤使用的工具
3. 预期的输出结果
4. 可能的风险和应对措施

请提供具体的规划方案。""",
    
    "observation_template": """# 任务执行分析指南

## 当前任务
{task_description}

## 执行状态
{execution_status}

## 执行结果
{execution_results}

## 分析要求
请分析上述任务的执行情况，包括：
1. 完成度评估（0-100%）
2. 质量分析（优秀/良好/一般/需改进）
3. 问题识别（如果有的话）
4. 改进建议
5. 下一步行动建议

请提供详细的观察分析。""",
    
    "stage_summary_template": """# 任务执行总结生成指南

## 当前阶段信息
- 阶段名称：{stage_name}
- 开始时间：{start_time}
- 当前时间：{current_time}

## 任务执行情况
{execution_status}

## 阶段成果
{stage_results}

## 总结要求
请生成本阶段的执行总结，包括：

### 1. 阶段概述
- 本阶段的主要目标
- 实际完成情况

### 2. 关键成果
- 具体产出和成果
- 质量评估

### 3. 执行分析
- 执行过程中的亮点
- 遇到的挑战和解决方案

### 4. 下一步计划
- 后续阶段的准备工作
- 需要注意的事项

请用专业但易懂的语言提供总结。""",
    
    "rewrite_template": """# 用户请求重写指南

## 历史对话
{dialogue_history}

## 最新请求
{latest_request}

## 重写要求
请根据历史对话上下文，重写用户的最新请求，使其：
1. 更加清晰和具体
2. 包含必要的上下文信息
3. 便于理解和执行
4. 保持用户的原始意图

## 重写原则
- 保持用户的核心需求不变
- 补充缺失的关键信息
- 消除歧义和模糊表达
- 使用更准确的术语

请提供重写后的请求。""",
    
    "workflow_select_template": """你是一个工作流选择专家。请根据用户的对话历史，从提供的工作流模板中选择最合适的一个。

**对话历史：**
{conversation_history}

**可用的工作流模板：**
{workflow_list}

**任务要求：**
1. 仔细分析对话历史中用户的核心需求和任务类型
2. 对比各个工作流模板的适用场景
3. 选择匹配的工作流，或者判断没有合适的工作流

**输出格式（JSON）：**
```json
{{
    "has_matching_workflow": true/false,
    "selected_workflow_index": 0
}}
```

请确保输出的JSON格式正确。
如果没有合适的工作流，请设置has_matching_workflow为false。
selected_workflow_index 从0 开始计数
""",
    
    "query_suggest_template": """# 建议生成指南
你的任务是根据上述的对话，生成接下来用户可能会问的问题，或者可能帮助用户解决相关更加深入的事情。

## 用户对话
{task_description}

## 要求
1. 建议的问题或者方向要与用户对话相关。
2. 建议的问题或者方向要具有一定的深度，能够帮助用户解决问题。
3. 建议的问题或者方向要具有一定的广度，能够帮助用户探索不同的角度。
4. 只生成3条建议。
5. 每条建议要简洁，不超过20个字符。
6. 建议是站在用户的角度。

## 输出格式
```
<suggest_item>
用户可能会问的问题1或者可以深入探索的方向1
</suggest_item>
<suggest_item>
用户可能会问的问题2或者可以深入探索的方向2
</suggest_item>
<suggest_item>
用户可能会问的问题3或者可以深入探索的方向3
</suggest_item>
```
""",
    
    "memory_extraction_template": """请分析以下对话，提取值得长期记忆的系统级信息。

<当前系统上下文>
{system_context}
</当前系统上下文>

<对话历史>
{formatted_conversation}
</对话历史>

请提取以下四种类型的系统级记忆：
1. **用户偏好 (preference)**：用户明确表达自身的喜好、习惯、风格偏好
2. **用户要求 (requirement)**：用户对AI回答方式、格式、内容的具体偏好要求，而不是用户要做的事情的记录
3. **用户人设 (persona)**：用户的身份、背景、经验、技能水平等个人信息
4. **约束条件 (constraint)**：用户提到的时间、环境、工作等约束条件

提取原则：
- 只提取明确表达的、具有长期价值的信息
- 忽略临时性、一次性的内容，用户要求做的事情不需要作为”用户要求“系统级的记忆。
- 确保记忆内容准确、具体
- 为每个记忆生成简洁明确的标识key
- memory的 key 和 content 中的描述尽可能使用绝对值，例如时间"明天"，要转换成绝对日期。
- 记忆必须要在User的表达的内容中提取，不能在系统上下文中以及AI的执行过程中提取。
- 不要提取系统上下文中已经提到的信息。

<返回格式要求>
请以JSON格式返回，格式如下：
{{
    "extracted_memories": [
        {{
            "key": "记忆的唯一标识",
            "content": "记忆的具体内容，精确不要有遗漏的信息",
            "type": "记忆类型(preference/requirement/persona/constraint/context/project/workflow/experience/learning/skill/note/bookmark/pattern）",
            "tags": ["相关标签1", "相关标签2"],
            "source": "提取依据的对话片段"
        }}
    ]
}}

如果没有找到值得记忆的信息，请返回空的extracted_memories数组。
{{
    "extracted_memories": []
}}
</返回格式要求>
""",
    
    "memory_deduplication_template": """请判断以下对话历史中是否存在重复的记忆。如果存在重复的记忆，请输出时间较早的重复的记忆的key。

判断是否有重复的记忆的规则要满足以下两个条件：
1. 两个记忆的key 基本上表达一样的内容，并且两个记忆的content 也基本上相似领域或者相反的意思的内容。
2. 两个记忆在一起会导致矛盾和冲突

示例1
记忆1的key：语言偏好
记忆1的content：中文
记忆2的key：语言偏好
记忆2的content：英文
结论：重复，用户偏好只能有一种

示例2
记忆1的key：用户的语言能力
记忆1的content：中文
记忆2的key：用户的语言能力
记忆2的content：英文
结论：不重复，用户可以有两种语言能力

示例3
记忆1的key：喜欢的运动
记忆1的content：用户喜欢足球
记忆2的key：喜欢的运动
记忆2的content：用户喜欢篮球
结论：不重复，用户可以有两种喜欢的运动

示例4
记忆1的key：称呼
记忆1的content：张三
记忆2的key：称呼
记忆2的content：李四
结论：重复，用户不能有两个称呼

当前存在的记忆：
{existing_memories}

输出格式为Json的key的列表，例如：
```json
{{
    "duplicate_keys": ["key1"]
}}
```
输出要求描述：
1. key1是要遗忘的记忆的key。
2. 不要输出任何其他的内容或解释，只输出Json格式的内容。
""",
    
    # ReAct模板
    "react_plan_template": """对已经执行的行为进行评估规划，不需要得到用户的确认，输出的形式为：当前***，接下来要做的是***。
- 不要输出工具的真实的名称，而是输出工具的描述。
- 不要做用户没有要求的任务。规划时只需要满足用户的请求，不要做过多额外的事情。""",
    
    "react_first_plan_template": """接下来开始对完成用户的需求进行评估规划，只进行评估规划，不要进行执行，也不需要得到用户的确认。
- 不要输出工具的真实的名称，而是输出工具的描述。
- 评估规划时，要重点参考推荐工作流的指导。
- 不要做用户没有要求的任务。规划时只需要满足用户的请求，不要做过多额外的事情。""",
    
    "react_execute_template": """接下来执行上述规划的内容，直接执行。
不要做以下的行为：
1. 最后对执行过程进行解释，例如：已完成用户需求，结束会话。
2. 不要输出后续的建议规划，例如：接下来要做的是***。
3. 不要调用会话结束工具。"""
}

# 便捷访问函数
def get_builtin_prompt(key: str) -> str:
    """获取内置prompt
    
    Args:
        key: prompt的键名
        
    Returns:
        prompt内容，如果不存在则返回空字符串
    """
    return BUILTIN_PROMPTS.get(key, "")

def list_builtin_prompts() -> list:
    """列出所有可用的内置prompt键名"""
    return list(BUILTIN_PROMPTS.keys())

def format_builtin_prompt(key: str, **kwargs) -> str:
    """格式化内置prompt模板
    
    Args:
        key: prompt的键名
        **kwargs: 模板参数
        
    Returns:
        格式化后的prompt内容
    """
    template = get_builtin_prompt(key)
    if template and kwargs:
        try:
            return template.format(**kwargs)
        except KeyError as e:
            print(f"警告：模板格式化失败，缺少参数: {e}")
            return template
    return template